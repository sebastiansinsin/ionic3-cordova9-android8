{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/android-fingerprint-auth/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,wCAAwC,CAAC;AAiFhF;IAAgD,8CAAsB;IAAtE;;IAuEA,CAAC;IAlDG;;;;OAIG;IACH,4CAAO,GAAP,UAAQ,OAAuB;QAC3B,IAAI,OAA2B,CAAC;QAChC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,OAAO,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,4CAAO,GAAP,UAAQ,OAAuB;QAC3B,IAAI,OAA0B,CAAC;QAC/B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,OAAO,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;OAGG;IACH,gDAAW,GAAX;QAKI,IAAI,OAAO,GAA2F,EAAE,WAAW,EAAE,IAAI,EAAE,kBAAkB,EAAE,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,CAAC;QACrL,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,OAAO,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;OAGG;IACH,2CAAM,GAAN,UAAO,OAGN;QAGG,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACN,iCAAC;AAAD,CAvEA,AAuEC,CAvE+C,sBAAsB,GAuErE","file":"index.js","sourceRoot":"","sourcesContent":["import { AndroidFingerprintAuth } from '@ionic-native/android-fingerprint-auth';\nexport interface AFAAuthOptions {\n    /**\n     * Required\n     * Used as the alias for your key in the Android Key Store.\n     */\n    clientId: string;\n    /**\n     * Used to create credential string for encrypted token and as alias to retrieve the cipher.\n     */\n    username?: string;\n    /**\n     * Used to create credential string for encrypted token\n     */\n    password?: string;\n    /**\n     * Required for decrypt()\n     * Encrypted user credentials to decrypt upon successful authentication.\n     */\n    token?: string;\n    /**\n     * Set to true to remove the \"USE BACKUP\" button\n     */\n    disableBackup?: boolean;\n    /**\n     * Change the language. (en_US or es)\n     */\n    locale?: string;\n    /**\n     * The device max is 5 attempts. Set this parameter if you want to allow fewer than 5 attempts.\n     */\n    maxAttempts?: number;\n    /**\n     * Require the user to authenticate with a fingerprint to authorize every use of the key.\n     * New fingerprint enrollment will invalidate key and require backup authenticate to\n     * re-enable the fingerprint authentication dialog.\n     */\n    userAuthRequired?: boolean;\n    /**\n     * Set the title of the fingerprint authentication dialog.\n     */\n    dialogTitle?: string;\n    /**\n     * Set the message of the fingerprint authentication dialog.\n     */\n    dialogMessage?: string;\n    /**\n     * Set the hint displayed by the fingerprint icon on the fingerprint authentication dialog.\n     */\n    dialogHint?: string;\n}\nexport interface AFADecryptOptions {\n    /**\n     * Biometric authentication\n     */\n    withFingerprint: boolean;\n    /**\n     * Authentication using backup credential activity\n     */\n    withBackup: boolean;\n    /**\n     * FingerprintAuth.CipherMode.DECRYPT\n     * Decrypted password\n     */\n    password: string;\n}\nexport interface AFAEncryptResponse {\n    /**\n     * Biometric authentication\n     */\n    withFingerprint: boolean;\n    /**\n     * Authentication using backup credential activity\n     */\n    withBackup: boolean;\n    /**\n     * base64encoded string representation of user credentials\n     */\n    token: string;\n}\n\nexport class AndroidFingerprintAuthMock extends AndroidFingerprintAuth {\n    ERRORS: {\n        BAD_PADDING_EXCEPTION: 'BAD_PADDING_EXCEPTION';\n        CERTIFICATE_EXCEPTION: 'CERTIFICATE_EXCEPTION';\n        FINGERPRINT_CANCELLED: 'FINGERPRINT_CANCELLED';\n        FINGERPRINT_DATA_NOT_DELETED: 'FINGERPRINT_DATA_NOT_DELETED';\n        FINGERPRINT_ERROR: 'FINGERPRINT_ERROR';\n        FINGERPRINT_NOT_AVAILABLE: 'FINGERPRINT_NOT_AVAILABLE';\n        FINGERPRINT_PERMISSION_DENIED: 'FINGERPRINT_PERMISSION_DENIED';\n        FINGERPRINT_PERMISSION_DENIED_SHOW_REQUEST: 'FINGERPRINT_PERMISSION_DENIED_SHOW_REQUEST';\n        ILLEGAL_BLOCK_SIZE_EXCEPTION: 'ILLEGAL_BLOCK_SIZE_EXCEPTION';\n        INIT_CIPHER_FAILED: 'INIT_CIPHER_FAILED';\n        INVALID_ALGORITHM_PARAMETER_EXCEPTION: 'INVALID_ALGORITHM_PARAMETER_EXCEPTION';\n        IO_EXCEPTION: 'IO_EXCEPTION';\n        JSON_EXCEPTION: 'JSON_EXCEPTION';\n        MINIMUM_SDK: 'MINIMUM_SDK';\n        MISSING_ACTION_PARAMETERS: 'MISSING_ACTION_PARAMETERS';\n        MISSING_PARAMETERS: 'MISSING_PARAMETERS';\n        NO_SUCH_ALGORITHM_EXCEPTION: 'NO_SUCH_ALGORITHM_EXCEPTION';\n        SECURITY_EXCEPTION: 'SECURITY_EXCEPTION';\n    };\n    /**\n     * Opens a native dialog fragment to use the device hardware fingerprint scanner to authenticate against fingerprints registered for the device.\n     * @param options {AFAAuthOptions} Options\n     * @returns {Promise<any>}\n     */\n    encrypt(options: AFAAuthOptions): Promise<AFAEncryptResponse> {\n        let reponse: AFAEncryptResponse;\n        return new Promise((resolve, reject) => {\n            resolve(reponse);\n        });\n    };\n    /**\n     * Opens a native dialog fragment to use the device hardware fingerprint scanner to authenticate against fingerprints registered for the device.\n     * @param options {AFAAuthOptions} Options\n     * @returns {Promise<any>}\n     */\n    decrypt(options: AFAAuthOptions): Promise<AFADecryptOptions> {\n        let reponse: AFADecryptOptions;\n        return new Promise((resolve, reject) => {\n            resolve(reponse);\n        });\n    };\n    /**\n     * Check if service is available\n     * @returns {Promise<any>} Returns a Promise that resolves if fingerprint auth is available on the device\n     */\n    isAvailable(): Promise<{\n        isAvailable: boolean;\n        isHardwareDetected: boolean;\n        hasEnrolledFingerprints: boolean;\n    }> {\n        let reponse: { isAvailable: boolean, isHardwareDetected: boolean, hasEnrolledFingerprints: boolean} = { isAvailable: true, isHardwareDetected: true, hasEnrolledFingerprints: true };\n        return new Promise((resolve, reject) => {\n            resolve(reponse);\n        });\n    };\n    /**\n     * Delete the cipher used for encryption and decryption by username\n     * @returns {Promise<any>} Returns a Promise that resolves if the cipher was successfully deleted\n     */\n    delete(options: {\n        clientId: string;\n        username: string;\n    }): Promise<{\n        deleted: boolean;\n    }> {\n        return new Promise((resolve, reject) => {\n            resolve({deleted: true});\n        });\n    };\n}\n"]}